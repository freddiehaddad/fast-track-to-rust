# Boilerplate

In the previous section, we used `cargo new` to create a Rust package, which is
the most common way to create a package. Running this command generated some
boilerplate code. When we used `cargo run`, a `target` directory was created and
the Rust compiler `rustc` was invoked, generating compiler-related files and an
executable binary within the `target` directory.

Let's clean everything up with `cargo clean` and return to the boilerplate. The
`cargo clean` command removes the target directory where all the generated code
resides. After running `cargo clean`, we're left with the boilerplate.

```console
$ cargo clean
     Removed 23 files, 2.9MiB total
```

```console
.
+ Cargo.lock
+ Cargo.toml
+ src
  + main.rs
```

For now, we'll focus on `main.rs` and discuss `Cargo.lock` and `Cargo.toml`
later.

## `main.rs`

`main.rs` is a Rust source file that gets created as part of a package. It
includes a function named `main` that serves as the program entry point.

The contents of `main.rs`:

```rust,editable
fn main() {
    println!("Hello, world!");
}
```

Some of the syntax should look familiar:

- Blocks of code are surrounded by curly braces `{}`.
- Statements end with a semicolon `;`.
- Function parameters are enclosed in parentheses `()`.
- String literals are enclosed in double quotes `""`.

What may not be familiar:

- `fn` is the keyword used to declare a function.
- `println!` is actually a macro, denoted by the `!` suffix.

# Summary

In this section, we:

- Explored the boilerplate code generated by `cargo new`.
- Reviewed some basic Rust syntax.

# Next

Let's dive into building our rustle program. We'll start by setting up the basic
structure and then gradually add more functionality.
